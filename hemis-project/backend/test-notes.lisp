;;;; test-notes.lisp --- backend tests for note persistence and git pinning

(require :asdf)

(let ((ql-setup (merge-pathnames "quicklisp/setup.lisp" (user-homedir-pathname))))
  (when (probe-file ql-setup)
    (load ql-setup)))

(setf (uiop:getenv "HEMIS_SKIP_SERVER") "1")

(load "hemis-project/backend/hemis.lisp")
(in-package :hemis)

(defun fail (msg)
  (format *error-output* "FAIL: ~A~%" msg)
  (finish-output *error-output*)
  (uiop:quit 1))

(defun ok (msg)
  (format t "OK: ~A~%" msg)
  (finish-output))

(defun write-file (path content)
  (uiop:ensure-all-directories-exist (list (uiop:pathname-directory-pathname path)))
  (uiop:with-output-file (out path :if-exists :supersede)
    (write-string content out)))

(uiop:with-temporary-file (:pathname db-path :keep t :suffix ".db")
  (let* ((*db-path* (uiop:native-namestring db-path))
         (*db* nil)
         (tmp-root (uiop:ensure-directory-pathname (uiop:temporary-directory)))
         (file (uiop:native-namestring (merge-pathnames "test.rs" tmp-root))))
    ;; prepare git repo with one commit
    (write-file file "fn main() {}\n")
    (uiop:run-program '("git" "init") :directory tmp-root :ignore-error-status t :output nil)
    (uiop:run-program '("git" "add" "test.rs") :directory tmp-root :ignore-error-status t :output nil)
    (uiop:run-program '("git" "-c" "user.name=Test" "-c" "user.email=test@example.com" "commit" "-m" "init")
                      :directory tmp-root :ignore-error-status t :output nil)
    (ensure-db)
    (let* ((params (make-hash-table :test 'equal))
           (node '("function_item" "parameters"))
           (root-str (uiop:native-namestring tmp-root)))
      (setf (gethash "file" params) file)
      (setf (gethash "projectRoot" params) root-str)
      (setf (gethash "line" params) 1)
      (setf (gethash "column" params) 0)
      (setf (gethash "text" params) "hello")
      (setf (gethash "nodePath" params) node)
      (let* ((created (handle-notes-create params))
             (note-id (gethash "id" created)))
        (unless (and note-id (stringp note-id))
          (fail "note id missing"))
        (unless (and (gethash "commitSha" created)
                     (gethash "blobSha" created))
          (fail "missing commit/blob on created note"))
        ;; second note on same node
        (let ((second (make-hash-table :test 'equal)))
          (maphash (lambda (k v) (setf (gethash k second) v)) params)
          (setf (gethash "text" second) "hello-again")
          (handle-notes-create second))
        (let* ((notes (handle-notes-list-for-file params))
               (note (first notes)))
          (unless (= 2 (length notes))
            (fail (format nil "expected two notes inserted, got ~A" (length notes))))
          (let ((saved (gethash "nodePath" note)))
            (unless (and (listp saved)
                         (every #'stringp saved)
                         (equal saved node))
              (fail (format nil "nodePath mismatch: ~A" saved))))
          (let ((fetched (handle-notes-get (let ((h (make-hash-table :test 'equal)))
                                             (setf (gethash "id" h) note-id)
                                             h))))
            (unless (string= note-id (gethash "id" fetched))
              (fail "fetched note id mismatch"))
            (unless (string= (gethash "text" fetched) "hello")
              (fail "fetched note text mismatch")))
          (let ((by-node (handle-notes-list-by-node params)))
            (unless (= 2 (length by-node))
              (fail (format nil "list-by-node expected 2, got ~A" (length by-node))))))
        ;; change file to invalidate blob
        (write-file file "fn main() { println!(\"changed\"); }\n")
        (let* ((current (file-git-info file))
               (commit (getf current :commit))
               (blob (getf current :blob))
               (fresh (handle-notes-list-for-file
                       (let ((h (make-hash-table :test 'equal)))
                         (setf (gethash "file" h) file)
                         (setf (gethash "projectRoot" h) root-str)
                         (setf (gethash "commit" h) commit)
                         (setf (gethash "blob" h) blob)
                         h)))
               (stale (handle-notes-list-for-file
                       (let ((h (make-hash-table :test 'equal)))
                         (setf (gethash "file" h) file)
                         (setf (gethash "projectRoot" h) root-str)
                         (setf (gethash "commit" h) commit)
                         (setf (gethash "blob" h) blob)
                         (setf (gethash "includeStale" h) t)
                         h))))
          (unless (= 0 (length fresh))
            (fail "expected no matching notes after blob change"))
          (unless (= 2 (length stale))
            (fail "expected stale notes to be returned"))
          (unless (every (lambda (n) (gethash "stale" n)) stale)
            (fail "stale flag not set")))))
    (ok "nodePath persisted with multiple notes and stale detection")))

(uiop:quit 0)
