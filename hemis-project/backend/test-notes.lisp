;;;; test-notes.lisp --- minimal backend test for note node_path persistence

(require :asdf)

(let ((ql-setup (merge-pathnames "quicklisp/setup.lisp" (user-homedir-pathname))))
  (when (probe-file ql-setup)
    (load ql-setup)))

(setf (uiop:getenv "HEMIS_SKIP_SERVER") "1")

(load "hemis-project/backend/hemis.lisp")
(in-package :hemis)

(defun fail (msg)
  (format *error-output* "FAIL: ~A~%" msg)
  (finish-output *error-output*)
  (uiop:quit 1))

(defun ok (msg)
  (format t "OK: ~A~%" msg)
  (finish-output))

(let* ((tmp (uiop:with-temporary-file (:pathname tmp-path :keep t :suffix ".db")
              tmp-path))
       (*db-path* (uiop:native-namestring tmp))
       (*db* nil))
  (ensure-db)
  (let* ((params (make-hash-table :test 'equal))
         (node '("function_item" "parameters")))
    (setf (gethash "file" params) "/tmp/test.rs")
    (setf (gethash "projectRoot" params) "/tmp")
    (setf (gethash "line" params) 1)
    (setf (gethash "column" params) 0)
    (setf (gethash "text" params) "hello")
    (setf (gethash "nodePath" params) node)
    (let* ((created (handle-notes-create params))
           (note-id (gethash "id" created)))
      (unless (and note-id (stringp note-id))
        (fail "note id missing"))
      ;; second note on same node
      (let ((second (make-hash-table :test 'equal)))
        (maphash (lambda (k v) (setf (gethash k second) v)) params)
        (setf (gethash "text" second) "hello-again")
        (handle-notes-create second))
      (let* ((notes (handle-notes-list-for-file params))
             (note (first notes)))
        (unless (= 2 (length notes))
          (fail (format nil "expected two notes inserted, got ~A" (length notes))))
        (let ((saved (gethash "nodePath" note)))
          (unless (and (listp saved)
                       (every #'stringp saved)
                       (equal saved node))
            (fail (format nil "nodePath mismatch: ~A" saved))))
        (let ((fetched (handle-notes-get (let ((h (make-hash-table :test 'equal)))
                                           (setf (gethash "id" h) note-id)
                                           h))))
          (unless (string= note-id (gethash "id" fetched))
            (fail "fetched note id mismatch"))
          (unless (string= (gethash "text" fetched) "hello")
            (fail "fetched note text mismatch")))
        (let ((by-node (handle-notes-list-by-node params)))
          (unless (= 2 (length by-node))
            (fail (format nil "list-by-node expected 2, got ~A" (length by-node)))))))
    (ok "nodePath persisted with multiple notes")))

(uiop:quit 0)
